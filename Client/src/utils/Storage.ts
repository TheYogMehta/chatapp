import { Filesystem, Directory } from "@capacitor/filesystem";
import { Capacitor } from "@capacitor/core";
import { executeDB } from "../services/sqliteService";

const VAULT_DIR = ".sys_blobs";
const CHUNK_SIZE = 64000;
const writeLocks = new Map<string, boolean>();

export const StorageService = {
  /**
   * MUTEX LOCKS: Prevents race conditions on concurrent writes.
   */
  async lock(key: string) {
    while (writeLocks.get(key)) {
      await new Promise((res) => setTimeout(res, 10));
    }
    writeLocks.set(key, true);
  },

  unlock(key: string) {
    writeLocks.delete(key);
  },

  /**
   * HELPERS: Path resolution
   */
  async getUniqueVaultPath(): Promise<{ fileName: string; path: string }> {
    const fileName = `${Date.now().toString(36)}_${Math.random()
      .toString(36)
      .slice(2, 10)}.bin`;
    const path = `${VAULT_DIR}/${fileName}`;
    return { fileName, path };
  },

  isLocalSystemPath(fileName: string): boolean {
    return fileName.startsWith("/") || fileName.includes("://");
  },

  /**
   * 1. SAVE RAW FILE (Profile Pics / Small Data)
   * Uses your processProfileImage output.
   */
  saveRawFile: async (
    data: string,
    existingFileName: string | null = null,
  ): Promise<string> => {
    let fileName: string;
    let path: string;

    if (!existingFileName) {
      const unique = await StorageService.getUniqueVaultPath();
      fileName = unique.fileName;
      path = unique.path;
    } else {
      fileName = existingFileName;
      path = StorageService.isLocalSystemPath(fileName)
        ? fileName
        : `${VAULT_DIR}/${fileName}`;
    }

    await StorageService.lock(fileName);
    try {
      const isLocal = StorageService.isLocalSystemPath(fileName);
      const writeOptions: any = { path, data, recursive: true };
      if (!isLocal) writeOptions.directory = Directory.Data;

      await Filesystem.writeFile(writeOptions);
      return fileName;
    } finally {
      StorageService.unlock(fileName);
    }
  },

  /**
   * 2. INITIALIZE MEDIA
   * Integrates the thumbnail generated by ImageUtils.generateThumbnail.
   */
  initMediaEntry: async (
    messageId: string,
    originalName: string,
    totalSize: number,
    mimeType: string,
    thumbnail: string | null = null,
    localPath: string | null = null,
  ): Promise<string> => {
    let finalFileName: string;
    let status: "pending" | "downloaded" = "pending";

    if (localPath) {
      // SENDER: Reference the gallery file directly
      finalFileName = localPath;
      status = "downloaded";
    } else {
      // RECEIVER: Create empty vault placeholder
      const { fileName, path } = await StorageService.getUniqueVaultPath();
      await Filesystem.writeFile({
        path,
        data: "",
        directory: Directory.Data,
        recursive: true,
      });
      finalFileName = fileName;
    }

    await executeDB(
      `INSERT INTO media (filename, original_name, file_size, size, mime_type, message_id, status, download_progress, thumbnail) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        finalFileName,
        originalName,
        totalSize,
        localPath ? totalSize : 0,
        mimeType,
        messageId,
        status,
        localPath ? 1.0 : 0.0,
        thumbnail, // Tiny Base64 from ImageUtils
      ],
    );

    return finalFileName;
  },

  /**
   * 3. APPEND CHUNK (Receiver Side)
   * Includes Disk-Full checking before writing.
   */
  appendChunk: async (fileName: string, base64Chunk: string): Promise<void> => {
    const path = `${VAULT_DIR}/${fileName}`;
    await StorageService.lock(fileName);

    try {
      // Check storage status (Native layer will throw if full)
      await Filesystem.appendFile({
        path,
        data: base64Chunk,
        directory: Directory.Data,
      });

      const stats = await Filesystem.stat({ path, directory: Directory.Data });

      await executeDB(
        `UPDATE media SET size = ?, status = 'downloading', download_progress = CAST(? AS REAL) / file_size WHERE filename = ?`,
        [stats.size, stats.size, fileName],
      );
    } catch (e: any) {
      if (
        e.message?.toLowerCase().includes("full") ||
        e.message?.toLowerCase().includes("space")
      ) {
        await executeDB(
          "UPDATE media SET status = 'error' WHERE filename = ?",
          [fileName],
        );
        throw new Error("DISK_FULL");
      }
      throw e;
    } finally {
      StorageService.unlock(fileName);
    }
  },

  /**
   * 4. READ CHUNK (Memory Efficient)
   * Works for both internal vault files and external Gallery files.
   */
  readChunk: async (fileName: string, chunkIndex: number): Promise<string> => {
    const isLocal = StorageService.isLocalSystemPath(fileName);
    const path = isLocal ? fileName : `${VAULT_DIR}/${fileName}`;

    const getUriOptions: any = { path };
    if (!isLocal) getUriOptions.directory = Directory.Data;

    const fileUri = await Filesystem.getUri(getUriOptions);
    const nativeUrl = Capacitor.convertFileSrc(fileUri.uri);

    // Fetch provides a streamable blob pointer
    const response = await fetch(nativeUrl);
    const blob = await response.blob();

    const start = chunkIndex * CHUNK_SIZE;
    const end = start + CHUNK_SIZE;
    const chunkBlob = blob.slice(start, end);

    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const result = reader.result as string;
        resolve(result.split(",")[1]);
      };
      reader.onerror = reject;
      reader.readAsDataURL(chunkBlob);
    });
  },

  /**
   * 5. DELETE FILE
   * Safety check: Never deletes files if they are external (Gallery).
   */
  deleteFile: async (fileName: string): Promise<void> => {
    try {
      if (!StorageService.isLocalSystemPath(fileName)) {
        await Filesystem.deleteFile({
          path: `${VAULT_DIR}/${fileName}`,
          directory: Directory.Data,
        });
      }
      await executeDB("DELETE FROM media WHERE filename = ?", [fileName]);
    } catch (e) {
      console.warn("Cleanup skipped or failed for:", fileName);
    }
  },

  /**
   * 6. GET FILE SRC
   * Returns a usable URL for the file (for img/video src).
   */
  getFileSrc: async (fileName: string): Promise<string> => {
    const isLocal = StorageService.isLocalSystemPath(fileName);
    const path = isLocal ? fileName : `${VAULT_DIR}/${fileName}`;
    
    const getUriOptions: any = { path };
    if (!isLocal) getUriOptions.directory = Directory.Data;

    try {
      const fileUri = await Filesystem.getUri(getUriOptions);
      return Capacitor.convertFileSrc(fileUri.uri);
    } catch (e) {
      console.error("Failed to get file src:", e);
      return "";
    }
  },

  /**
   * 7. SAVE TO DOWNLOADS
   * Exports file to visible Downloads/chatapp/ folder with smart renaming.
   */
  saveToDownloads: async (vaultFileName: string, originalName: string): Promise<string> => {
    // 1. Ensure target directory exists
    const targetDir = "chatapp";
    try {
      await Filesystem.mkdir({
        path: targetDir,
        directory: Directory.Documents,
        recursive: true
      });
    } catch (e) {
      // Ignore if exists
    }

    // 2. Find unique filename
    let finalName = originalName;
    let counter = 1;

    // Remove file extension for base name calculation
    const nameParts = originalName.split('.');
    const ext = nameParts.length > 1 ? nameParts.pop() : '';
    const nameBase = nameParts.join('.');

    // Loop until we find a non-existing filename
    while (true) {
      try {
        await Filesystem.stat({
          path: `${targetDir}/${finalName}`,
          directory: Directory.Documents
        });
        // If stat succeeds, file exists
        finalName = `${nameBase} (${counter})${ext ? '.' + ext : ''}`;
        counter++;
      } catch (e) {
        // If stat fails, file doesn't exist -> safe to use
        break;
      }
    }

    // 3. Copy/Write content
    const srcPath = `${VAULT_DIR}/${vaultFileName}`;
    const destPath = `${targetDir}/${finalName}`;

    await Filesystem.copy({
        from: srcPath,
        directory: Directory.Data,
        to: destPath,
        toDirectory: Directory.Documents
    });

    return destPath;
  }
};
